import numpy
import typing
import vector.backends.object
from vector._methods import Azimuthal as Azimuthal, AzimuthalRhoPhi as AzimuthalRhoPhi, AzimuthalXY as AzimuthalXY, Longitudinal as Longitudinal, LongitudinalEta as LongitudinalEta, LongitudinalTheta as LongitudinalTheta, LongitudinalZ as LongitudinalZ, Lorentz as Lorentz, LorentzMomentum as LorentzMomentum, Momentum as Momentum, Planar as Planar, PlanarMomentum as PlanarMomentum, Spatial as Spatial, SpatialMomentum as SpatialMomentum, Temporal as Temporal, TemporalT as TemporalT, TemporalTau as TemporalTau, Vector as Vector, Vector2D as Vector2D, Vector3D as Vector3D, Vector4D as Vector4D, VectorProtocol as VectorProtocol
from vector._typeutils import BoolCollection as BoolCollection, FloatArray as FloatArray, ScalarCollection as ScalarCollection

ArrayLike = ScalarCollection
T = typing.TypeVar('T', bound='VectorNumpy')
V = typing.TypeVar('V')
SameVectorNumpyType = typing.TypeVar('SameVectorNumpyType', bound='VectorNumpy')

class GetItem:
    @typing.overload
    def __getitem__(self, where: str) -> FloatArray: ...
    @typing.overload
    def __getitem__(self, where: typing.Any) -> float | FloatArray: ...

class CoordinatesNumpy:
    lib = numpy
    dtype: numpy.dtype[typing.Any]

class AzimuthalNumpy(CoordinatesNumpy, Azimuthal):
    ObjectClass: type[vector.backends.object.AzimuthalObject]

class LongitudinalNumpy(CoordinatesNumpy, Longitudinal):
    ObjectClass: type[vector.backends.object.LongitudinalObject]

class TemporalNumpy(CoordinatesNumpy, Temporal):
    ObjectClass: type[vector.backends.object.TemporalObject]

class AzimuthalNumpyXY(AzimuthalNumpy, AzimuthalXY, GetItem, FloatArray):
    ObjectClass = vector.backends.object.AzimuthalObjectXY
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> AzimuthalNumpyXY: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray, FloatArray]: ...
    @property
    def x(self) -> FloatArray: ...
    @property
    def y(self) -> FloatArray: ...

class AzimuthalNumpyRhoPhi(AzimuthalNumpy, AzimuthalRhoPhi, GetItem, FloatArray):
    ObjectClass = vector.backends.object.AzimuthalObjectRhoPhi
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> AzimuthalNumpyRhoPhi: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray, FloatArray]: ...
    @property
    def rho(self) -> FloatArray: ...
    @property
    def phi(self) -> FloatArray: ...

class LongitudinalNumpyZ(LongitudinalNumpy, LongitudinalZ, GetItem, FloatArray):
    ObjectClass = vector.backends.object.LongitudinalObjectZ
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> LongitudinalNumpyZ: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray]: ...
    @property
    def z(self) -> FloatArray: ...

class LongitudinalNumpyTheta(LongitudinalNumpy, LongitudinalTheta, GetItem, FloatArray):
    ObjectClass = vector.backends.object.LongitudinalObjectTheta
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> LongitudinalNumpyTheta: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray]: ...
    @property
    def theta(self) -> FloatArray: ...

class LongitudinalNumpyEta(LongitudinalNumpy, LongitudinalEta, GetItem, FloatArray):
    ObjectClass = vector.backends.object.LongitudinalObjectEta
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> LongitudinalNumpyEta: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray]: ...
    @property
    def eta(self) -> FloatArray: ...

class TemporalNumpyT(TemporalNumpy, TemporalT, GetItem, FloatArray):
    ObjectClass = vector.backends.object.TemporalObjectT
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> TemporalNumpyT: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray]: ...
    @property
    def t(self) -> FloatArray: ...

class TemporalNumpyTau(TemporalNumpy, TemporalTau, GetItem, FloatArray):
    ObjectClass = vector.backends.object.TemporalObjectTau
    dtype: numpy.dtype[typing.Any]
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> TemporalNumpyTau: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    @property
    def elements(self) -> tuple[FloatArray]: ...
    @property
    def tau(self) -> FloatArray: ...

class VectorNumpy(Vector, GetItem):
    lib = numpy
    dtype: numpy.dtype[typing.Any]
    def allclose(self, other: VectorProtocol, rtol: float | FloatArray = 1e-05, atol: float | FloatArray = 1e-08, equal_nan: bool | FloatArray = False) -> BoolCollection: ...
    def sum(self, axis: int | None = None, dtype: numpy.dtype[typing.Any] | str | None = None, out: ArrayLike | None = None, keepdims: bool = False, initial: typing.Any = None, where: typing.Any = None) -> SameVectorNumpyType: ...
    def __eq__(self, other: typing.Any) -> typing.Any: ...
    def __ne__(self, other: typing.Any) -> typing.Any: ...
    def __reduce__(self) -> str | tuple[typing.Any, ...]: ...
    def __array_ufunc__(self, ufunc: typing.Any, method: typing.Any, *inputs: typing.Any, **kwargs: typing.Any) -> typing.Any: ...
    def __array_function__(self, func: typing.Any, types: typing.Any, args: typing.Any, kwargs: typing.Any) -> typing.Any: ...

class VectorNumpy2D(VectorNumpy, Planar, Vector2D, FloatArray):
    ObjectClass = vector.backends.object.VectorObject2D
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> VectorNumpy2D: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    @property
    def azimuthal(self) -> AzimuthalNumpy: ...
    def __setitem__(self, where: typing.Any, what: typing.Any) -> None: ...

class MomentumNumpy2D(PlanarMomentum, VectorNumpy2D):
    ObjectClass = vector.backends.object.MomentumObject2D
    dtype: numpy.dtype[typing.Any]
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __setitem__(self, where: typing.Any, what: typing.Any) -> None: ...

class VectorNumpy3D(VectorNumpy, Spatial, Vector3D, FloatArray):
    ObjectClass = vector.backends.object.VectorObject3D
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> VectorNumpy3D: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    @property
    def azimuthal(self) -> AzimuthalNumpy: ...
    @property
    def longitudinal(self) -> LongitudinalNumpy: ...
    def __setitem__(self, where: typing.Any, what: typing.Any) -> None: ...

class MomentumNumpy3D(SpatialMomentum, VectorNumpy3D):
    ObjectClass = vector.backends.object.MomentumObject3D
    dtype: numpy.dtype[typing.Any]
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __setitem__(self, where: typing.Any, what: typing.Any) -> None: ...

class VectorNumpy4D(VectorNumpy, Lorentz, Vector4D, FloatArray):
    ObjectClass = vector.backends.object.VectorObject4D
    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> VectorNumpy4D: ...
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    @property
    def azimuthal(self) -> AzimuthalNumpy: ...
    @property
    def longitudinal(self) -> LongitudinalNumpy: ...
    @property
    def temporal(self) -> TemporalNumpy: ...
    def __setitem__(self, where: typing.Any, what: typing.Any) -> None: ...

class MomentumNumpy4D(LorentzMomentum, VectorNumpy4D):
    ObjectClass = vector.backends.object.MomentumObject4D
    dtype: numpy.dtype[typing.Any]
    def __array_finalize__(self, obj: typing.Any) -> None: ...
    def __setitem__(self, where: typing.Any, what: typing.Any) -> None: ...

def array(*args: typing.Any, **kwargs: typing.Any) -> VectorNumpy: ...
