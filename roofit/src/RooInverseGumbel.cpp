/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooAbsCategory.h"
#include "RooAbsReal.h"
#include "RooInverseGumbel.h"
#include "TMath.h"
#include <math.h>

ClassImp(RooInverseGumbel)

    RooInverseGumbel::RooInverseGumbel(const char * name, const char * title, RooAbsReal & _x, RooAbsReal & _mu, RooAbsReal & _sigma, RooAbsReal & _alpha)
    : RooAbsPdf(name, title)
    , x("x", "x", this, _x)
    , mu("mu", "mu", this, _mu)
    , sigma("sigma", "sigma", this, _sigma)
    , alpha("alpha", "alpha", this, _alpha) {}

RooInverseGumbel::RooInverseGumbel(const RooInverseGumbel & other, const char * name)
    : RooAbsPdf(other, name)
    , x("x", this, other.x)
    , mu("mu", this, other.mu)
    , sigma("sigma", this, other.sigma)
    , alpha("alpha", this, other.alpha) {}

Double_t RooInverseGumbel::evaluate() const {
    Double_t reciprocal = 1. / sigma;
    Double_t z          = (x - mu) * reciprocal;
    Double_t expZ       = exp(z);

    Double_t ret = expZ * exp(-alpha * expZ);

    return ret;
}

//  Int_t RooInverseGumbel::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
//  {
//    if (matchArgs(allVars,analVars,x)) return 1 ;
//    return 0 ;
//  }

//  Double_t RooInverseGumbel::analyticalIntegral(Int_t code, const char* rangeName) const
//  {
//    assert(code==1) ;
//    Double_t lower = x.min(rangeName);
//    Double_t upper = x.max(rangeName);

//    Double_t reciprocal = 1/sigma;
//    Double_t expUpper = exp(reciprocal*(upper - mu));
//    Double_t expLower = exp(reciprocal*(lower - mu));

//    Double_t difference = exp( -alpha * expLower) - exp(-alpha * expUpper);
//    Double_t integral = (alpha / sigma) * difference;

//    return difference ;
//  }

// Double_t RooInverseGumbel::getLogVal(const RooArgSet* set) const {
//     Double_t z = (x-mu)/sigma;

//     Double_t logPdf = z - alpha * exp(z);
//     Double_t logNormalisation = log(analyticalIntegral(1,0));
//     Double_t logValue = logPdf - logNormalisation;
//     return logValue;
// }
