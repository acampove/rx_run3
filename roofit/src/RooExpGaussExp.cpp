/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...
#ifndef ROOEXPGAUSSEXP_CXX
#define ROOEXPGAUSSEXP_CXX

#include "Riostream.h"

#include "RooAbsCategory.h"
#include "RooAbsReal.h"
#include "RooExpGaussExp.h"
#include "TMath.h"
#include <math.h>

ClassImp(RooExpGaussExp)

    RooExpGaussExp::RooExpGaussExp(const char * name, const char * title, RooAbsReal & _x, RooAbsReal & _mu, RooAbsReal & _sigma, RooAbsReal & _aLow, RooAbsReal & _aHigh)
    : RooAbsPdf(name, title)
    , x("x", "x", this, _x)
    , mu("mu", "mu", this, _mu)
    , sigma("sigma", "sigma", this, _sigma)
    , aLow("aLow", "aLow", this, _aLow)
    , aHigh("aHigh", "aHigh", this, _aHigh) {}

RooExpGaussExp::RooExpGaussExp(const RooExpGaussExp & other, const char * name)
    : RooAbsPdf(other, name)
    , x("x", this, other.x)
    , mu(" mu", this, other.mu)
    , sigma(" sigma", this, other.sigma)
    , aLow(" kLow", this, other.aLow)
    , aHigh(" kHigh", this, other.aHigh) {}

Double_t RooExpGaussExp::evaluate() const {
    Double_t z = (x - mu) / sigma;

    if (z <= -aLow) {
        return exp(0.5 * aLow * aLow + aLow * z);
    } else if (z > -aLow && z <= aHigh) {
        return exp(-0.5 * z * z);
    } else {
        return exp(0.5 * aHigh * aHigh - aHigh * z);
    }
}

Int_t RooExpGaussExp::getAnalyticalIntegral(RooArgSet & allVars, RooArgSet & analVars, const char * rangeName) const {

    if (matchArgs(allVars, analVars, x)) return 1;

    return 0;
}

Double_t RooExpGaussExp::getNormalisationLowerTail() const { return (sigma / aLow) * exp(-0.5 * aLow * aLow); }

Double_t RooExpGaussExp::getNormalisationGaussian() const {
    Double_t constant = sigma * sqrtPi * invSqrt2;
    return constant * (erf(aHigh * invSqrt2) + erf(aLow * invSqrt2));
}

Double_t RooExpGaussExp::getNormalisationHighTail() const { return (sigma / aHigh) * exp(-0.5 * aHigh * aHigh); }

Double_t RooExpGaussExp::getCumulativeValue(Double_t z) const {
    if (z <= -aLow) {
        return (sigma / aLow) * exp(0.5 * aLow * aLow + aLow * z);
    } else if (z > -aLow && z <= aHigh) {
        Double_t lowerTailNorm    = getNormalisationLowerTail();
        Double_t centralGaussNorm = sigma * sqrtPi * invSqrt2 * (erf(aLow * invSqrt2) + erf(invSqrt2 * z));
        return lowerTailNorm + centralGaussNorm;
    } else {
        Double_t lowerTailNorm    = getNormalisationLowerTail();
        Double_t centralGaussNorm = getNormalisationGaussian();
        Double_t highTailNorm     = (sigma / aHigh) * (exp(-0.5 * aHigh * aHigh) - exp(0.5 * aHigh * aHigh - aHigh * z));
        return lowerTailNorm + centralGaussNorm + highTailNorm;
    }
}

Double_t RooExpGaussExp::analyticalIntegral(Int_t code, const char * rangeName) const {
    assert(code == 1 || code == 2);

    Double_t zMin = (x.min(rangeName) - mu) / sigma;
    Double_t zMax = (x.max(rangeName) - mu) / sigma;

    Double_t cumlativeZMin = getCumulativeValue(zMin);
    Double_t cumlativeZMax = getCumulativeValue(zMax);

    return cumlativeZMax - cumlativeZMin;
}

Double_t RooExpGaussExp::getLogVal(const RooArgSet * set) const {
    Double_t normalisation = log(analyticalIntegral(1, 0));
    Double_t z             = (x - mu) / sigma;

    if (z <= -aLow) {
        return 0.5 * aLow * aLow + aLow * z - normalisation;
    } else if (z > -aLow && z <= aHigh) {
        return -0.5 * z * z - normalisation;
    } else {
        return 0.5 * aHigh * aHigh - aHigh * z - normalisation;
    }
}

#endif
